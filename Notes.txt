What is node.js?
   Node.jsÂ® is a JavaScript runtime built on Chrome's V8 JavaScript engine.

Java Script Runtime:

 -It is Program written in either c / c++ to execute javascript assembly instructions.

Types of Runtime:

1.Embeded runtime
  The runtime embeded into another program/runtime.
Tomcat - HttpServer + jvm
Javascript Runtime : inside every browser

2.Standalone runtime
jvm
clr
javascript Engine - v8

Google distributed v8 in two mode, one is embeded -chrome,standlone mode.

Google only first distribtued javascript engine(v8) code in open source.

Node.js was created based on v8 javascript engine for building non blocking , async 
io applications - network applications in javascript language.
..........................................................................................
What is blocking?
 The code which waits for result during execution.
 The next line of code will not execute,before completion of previous code.

What is Non blocking && Async ?
 The code which takes time (i dont know how much time it will take)
 but i dont want to wait until the previouse code complete.

Which can block? which code takes longer time?

-ANY IO 
   -INPUT/OUTPUT -  
  if you are reading / writing data  from and into network socket
  if you are reading/writing data from the datasources - db
  if you are reading/writing data from and into the file system.

-cpu intensive taks
  -running for/while loop infintly or long times. 1 to 100000000
  -graphics apps which process images/vidoes

How to design non blocking io Architectures?


File Descriptors:
 - it is ds, array, having values 
Integer value	Name	<unistd.h> symbolic constant[1]	<stdio.h> file stream[2]
0	Standard input	STDIN_FILENO	stdin
1	Standard output	STDOUT_FILENO	stdout
2	Standard error	STDERR_FILENO	stderr

-Every process when it is created, a new file descriptor table is initalized with three values
 -stdin-keyword
 -stdout-terminal
 -stderr-terminal

if you are going to do io operation
 -reading a text file from c:\drive(hardisk)
you can take any language
java

Types of api:

1.highlevel api -  used by language
2.system calls- sys calls -lowlevel api -  used by os

console.log() -high level api
fsstream.read() -high level api

Process:
  Container/Runtime for applications.
  Every Process has its own memory 
  Every Process has its own processid.
 On process we can run our app code.

Modern Processes has sub processs-Threads


How Web works? How web server works?

1000 requests (io request)---------- 1000 threads will be created

                              "Thread Per Request Model"


C10k - problem - 2000
 -  a web server should handle 10 connections in a time.

How to utilize the existing hardware resources - memory cpu with max concurrency.

10 k - hardware
15 k  -hardware

single hardware -15k

in order to achive c10k problem solution?

-Which is taking more resource? 
   Thread

How to minimize no of threads, how to avoid memory allocations and ctx switch.


blocking api in linux:
-read,receive,open.....

Non blocking api
In 2000, linux operating system added the first non blocking api

select  +Read =  first non blocking arch

poll api : emitting events - Event driven architecture


Pull model : The process should fire api(pulling) data from the kernal
Push/poll : The kernal push the data to the process when data is ready via events

Poll had some issues, 

EPoll:
.....
 -framework for watching fs entries, emits events and data to the process.

Node internal Architecture?

 - Node is the most successful project which implemented "c10k" problom solution architecture.

Node.js implements non blocking arch with help of javascript and libuv.


libuv:
 The c platform abstraction lib.
libuv is a multi-platform support library with a focus on asynchronous I/O.
.............................................................................................

According the libuv

.Full-featured event loop backed by epoll, kqueue, IOCP, event ports

All network io operations are performed by "a Thread" called event loop thread.

There is only one Event loop thread per node process.

.............................................................................................
					Threading in node process

There are two types of threads.

1.Event loop thread
   only one event loop thread or main loop thread, main thread, event thread.

 Event loop thread handles "Non blocking network io(socket) calls- tcp,http,udp,pipes,timers

2.Worker pool(more - n no of threads) thread /Workers threads - Thread Pools
  Libuv initalizes the n- of let say 10 threads in advance when node process is being started.


Work Pool Thread: 
  -It is used per task thread - request per thread model- dedidcated thread.

"Async vs non blocking"

  -Non blocking means the current thread not to be blocked for io operation.

  -Async means
       - the current thread not to be blocked for io operations.
       - schduling the task in different thread of execution , later you can collect result          via events,callbacks,futures

Work pool thread can be used

-For non blocking file system io operation

For async fs api, thread pool thread is created used but it wont be blocked but rather other 
for sync fs api is created used but it cant be released until the fs operation is completed
............................................................................................
		How to implement non blocking async operations are implemented
.............................................................................................

How to process events? styles of writing async programmings?

1.callback style
2.Promise style
3.async...await


 callback ;
  it is function used to handle async results.
  it is registered when the call is made
  it is invoked once the event is arrived to the node process
  when callback functions runs the current thread to be blocked to return data.

How to implement callbacks


1.you need node high level async api - io apis, timers
2.you need higher order function - function passed parameter to another function.

How epoll works in the kernal side similarly we have same simulation in the node process level.

Even loop thread cycles.

-Thread is created running inside an infite loop;

  for(;;){ 
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€>â”‚           timers          â”‚   --- attach callback functions to execute that phase
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚     pending callbacks     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚       idle, prepare       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚   incoming:   â”‚
â”‚  â”‚           poll            â”‚<â”€â”€â”€â”€â”€â”¤  connections, â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚   data, etc.  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”‚           check           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”¤      close callbacks      â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  }

timers: this phase executes callbacks scheduled by setTimeout() and setInterval().
pending callbacks: executes I/O callbacks deferred to the next loop iteration.
idle, prepare: only used internally.
poll: retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, and setImmediate()); node will block here when appropriate.
check: setImmediate() callbacks are invoked here.
close callbacks: some close callbacks, e.g. socket.on('close', ...).


//non blocking implementation : timers 

// timers,network io code

function delay(action){
   //non blocking high level api
   setTimeout(action,5000);
}
function blockMe(message){
    console.log(message)
}
function tick(callback){
    setInterval(callback,1000)
}
function justRunAsync(){
    setImmediate(function(){
        console.log('runs in the check phase')
    })
}
blockMe('start')
justRunAsync();
delay(function(){
    console.log('got it')
});
tick(function(){
    console.log('ping')
})
blockMe('end')
............................................................................................

Arrow functions:
//arrow functions are simple way of writing anonmous functions

//es 5 style
let hello = function () {
    console.log('hello');
};
hello();
//es 6 style - arrow
hello = () => {
    console.log('hello');
};
hello()
//if there is single line of body , you can remove {}
hello = () => console.log('hello');
hello();
//args and parameters
let add = function (a, b) {
    return a + b;
};
console.log(add(10, 10));

add = (a, b) => {
    return a + b;
};
console.log(add(10, 10));
//function returns only,remove {} and return statement 
add = (a, b) => a + b;
console.log(add(10, 10));

add = (a = 1, b = 1) => a + b;
console.log(add());
console.log(add(10, 10));

//single param,no default , return the same
let message = name => name;
console.log(message('subramanian'))
//higher order function and arrow: function as parameter

let login = function (username, password, success, failure) {
    if (username === 'admin' && password === 'admin') {
        success('login success')
    } else {
        failure('login failed')
    }
}
login('admin', 'admin', function (status) {
    console.log(status)
}, function (err) {
    console.log(err);
})
login = (username, password, success, failure) => {
    if (username === 'admin' && password === 'admin') {
        success('login success')
    } else {
        failure('login failed')
    }
}
login('admin', 'admin', status => console.log(status), err => console.log(err));
login('ff', 'xxx', status => console.log(status), err => console.log(err));


.............................................................................................

Callback is very core, without which you cant write non blocking apps.

.............................................................................................
			 Callback Chaining -Async composition-Callback Nesting
............................................................................................

-the out put of one callback(async result) will be input to another callback
  
    -api which returns data - async
       --based on api you need to call another api



//callback ; the out put of one callback will be input to another one.

//resolve => success
//reject => failure

let getUser = (resolve, reject) => {
    let user = {
        name: 'admin',
        password: 'admin'
    }
    //check user present
    if (user) {
        //async code
        setTimeout(resolve, 1000, user);
    } else {
        setTimeout(reject, 1000, { message: 'User not found not' });
    }

};

let login = (user, resolve, reject) => {
    //check  valid user
    if (user.name === 'admin' && user.password === 'admin') {
        //async code
        setTimeout(resolve, 1000, 'login success');
    } else {
        setTimeout(reject, 1000, 'login failed');
    }

};
let showDashboard = (status, resolve, reject) => {
    //check  valid user
    if (status === 'login success') {
        //async code
        setTimeout(resolve, 1000, 'You are admin');
    } else {
        setTimeout(reject, 1000, 'You are guest');
    }

};

getUser(user => {
    console.log(user)
    login(user, status => {
        console.log(status)
        showDashboard(status, apage => { 
            console.log(apage)
        }, gpage => { 
            console.log(gpage)
        });
    }, error => {
        console.log(error);
    });
}, error => {
    console.log(error);
});


fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})


Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

No! -------Callback Hell.
............................................................................................
Callback Hell:

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand,maintain,debug,scale Which 
  called as "Callback Hell".

How to write better async/non blocking code without callbacks?

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writting callbacks.


In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns


Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

...........................................................................................

...........................................................................................

In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committe introduced promise design pattern  as  "Promise" Object  in javascript.

Promises and non blocking,async and callback hell issues:
.........................................................

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async callback based  implementations.

Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.

Promise Implemenation:

1. Create Promise Object from Promise contructor
2. Create Promise object from factory apis 

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race




function blockMe(message) {
    console.log(message)
}
let getSuccessPromise = () => {
    return Promise.resolve('success'); //retuns promise object
};

let getFailurePromise = () => {
    return Promise.reject('error'); //retuns promise object
};
blockMe('start')
getSuccessPromise()
    .then(res => console.log(res));

getFailurePromise()
    .catch(res => console.log(res));

//error and failure
let login = (username = 'admin', password = 'admin') => {
    if (username === 'admin' && password === 'admin') {
        return Promise.resolve('login success')
    } else {
        return Promise.reject('login failed')
    }
};
login()
    .then(res => console.log(res))
    .catch(res => console.log(res));
blockMe('end')
..........................................................................................

//Promise constructor ; when you are converting an existing callback apis into promise style.

// function delay(callback) {
//     setTimeout(callback, 5000, "hello")
// }
// delay((message) => console.log(message))


function delay() {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 5000, "hello")
    })

}
delay().then(res=>console.log(res))



let getUser = () => {
    console.log('user is called');
    return new Promise((resolve, reject) => {
        let user = {
            name: 'admin',
            password: 'admin'
        }
        //check user present
        if (user) {
            //async code
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, { message: 'User not found not' });
        }
    })
};

let login = user => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        //check  valid user
        if (user.name === 'admin' && user.password === 'admin') {
            //async code
            setTimeout(resolve, 1000, 'login success');
        } else {
            setTimeout(reject, 1000, 'login failed');
        }
    })


};
let showDashboard = status => {
    console.log('showdashboard is called')
    return new Promise((resolve, reject) => {
        //check  valid user
        if (status === 'login success') {
            //async code
            setTimeout(resolve, 1000, 'You are admin');
        } else {
            setTimeout(reject, 1000, 'You are guest');
        }
    });

};

// getUser(user => {
//     console.log(user)
//     login(user, status => {
//         console.log(status)
//         showDashboard(status, apage => { 
//             console.log(apage)
//         }, gpage => { 
//             console.log(gpage)
//         });
//     }, error => {
//         console.log(error);
//     });
// }, error => {
//     console.log(error);
// });

//promise chaining
// getUser().then(user => {
//     console.log('user is called');
//     login(user).then(status => {
//         console.log('login is called')
//         showDashboard(status)
//             .then(page => console.log('showdashboard is called'))
//             .catch(error => console.log(errror));
//     }).catch(err => {
//         console.log(err);
//     })
// }).catch(err => {
//     console.log(err);
// })
//v2
// getUser()
//     .then(user => {
//         return login(user)
//     })
//     .then(status => {
//         return showDashboard(status)
//     })
//     .catch(error => console.log(error));

getUser()
    .then(user => login(user))
    .then(status => showDashboard(status))
    .catch(error => console.log(error));


//////////////////////////////////////////////////////////////////////////////////////////

Promise Hell:

 In large code base, you can see many "thenables", how to reduce thenables.

ES 7 introduced even simple keywords , looks like sync programm/sequencial call.
"Sync style of async programm"

"async function and await keyword.


let getUser = () => {
    console.log('user is called');
    return new Promise((resolve, reject) => {
        let user = {
            name: 'admin',
            password: 'admin'
        }
        //check user present
        if (user) {
            //async code
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, { message: 'User not found not' });
        }
    })
};

let login = user => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        //check  valid user
        if (user.name === 'admin' && user.password === 'admin') {
            //async code
            setTimeout(resolve, 1000, 'login success');
        } else {
            setTimeout(reject, 1000, 'login failed');
        }
    })


};
let showDashboard = status => {
    console.log('showdashboard is called')
    return new Promise((resolve, reject) => {
        //check  valid user
        if (status === 'login success') {
            //async code
            setTimeout(resolve, 1000, 'You are admin');
        } else {
            setTimeout(reject, 1000, 'You are guest');
        }
    });

};


// getUser()
//     .then(user => login(user))
//     .then(status => showDashboard(status))
//     .catch(error => console.log(error));

// async function main(){

// }
// main();
let main = async () => {
    try {
        let user = await getUser()
        let status = await login(user);
        let page = await showDashboard(status);
        console.log(user, status, page);
    }
    catch (err) {
        console.log(err);
    }
};
main()
.............................................................................................
				 Modularity
..............................................................................................

Modularity:
..........

In java Modularity , is presented via "Packages"

Package organize the code  logically.

Customer.java

package com.ibm.cms

public class Customer{}

Java organizes code folders and files Physically.

d:/javaapps/src/
    com/ibm/cms/Customer.java


What about javascript Modularity?

 Javascript is file based modularity physically
 but logically there is no such modularity at language level.

collection of variable declarations and function.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.
 

Module design patterns came.

1.Namespace design pattern : 2000 : jquery
2.AMD -Async Module Defintion : dojo
---------------------------------------------------------
3.CJS - Common JS =  namespace + amd
4.ES 6 Module design pattern  = amd + cjs
------------------------------------------------------------
5.System = AMD = CJS + ES 6
6.UMD = NAMESPACE + AMD + CJS = ES 6



CJS ; implemented inside node js. node supports commonjs by default.

I can organize the code , based on these patterns, but what about runtimes?
  js runtime never suppport these patterns directly then each design pattern is lib.

 Loaders : it is simple js lib to help link and load js files.

////////////////////////////////////////////////////////////////////////////////////////////

lets start cjs first;
......................

cjs is built in node js.
node supports cjs in built. no separate loader or linker is required
but if you run cjs code on browsers , we need loaders.


How to implement cjs in node? How to share code across the files and how to link files


keywords

-require('./folder/fileName')
  to link files
-exports
   -used to share code in form of object
   -code is packed inside object and shared that object
-module.exports
   -used to share code as it is.


mylib.js
exports.name = 'Subramanian';
exports.city = 'coimbatore';
exports.state = 'Tamil Nadu'
exports.salary = 1000
exports.status = true;
exports.calculate = () => 1000
exports.skills = ['javascript', 'nodejs']
exports.location = {
    lat: 18889.899,
    lng: 908766
}


class TodoService {
    findAll() {
        return 'Todoservice';
    }
    //callback api
    // findAll(callback) {
    //     setTimeout(callback,1000,'todos')
    // }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, 'todos')
        })
    }
}
module.exports = TodoService

const info = require('./mylibe')
const { name } = require('./mylibe')
const TodoService = require('./todo.service')
console.log(info, name);

let service = new TodoService();
// console.log(service.findAll());
// service.findAll(todos=>console.log(todos))
const main = async () => {
    try {
        const todos = await service.findAll();
        console.log(todos);
    }
    catch (err) {

    }

}
main();
............................................................................................

Types of modules

1.node built in modules

............................................................................................
..............................................................................................					  IO 
                 Async io and Sync IO - Nonblocking IO / Blocking IO
..............................................................................................
Running code inside worker poll thread

const fs = require('fs')


function blockMe(message){
  console.log(message);
}

const filePath = './src/assets/info.txt'
const fileOptions = {
    encoding:'utf-8'
}

blockMe('start reading')
//async/non blocking  file api :
fs.readFile(filePath, fileOptions, (err, data) => {
    if (err) {
        throw err;
    }
    console.log(data);
})
blockMe('start ending')
.............................................................................................
Running code inside worker poll thread

const fs = require('fs')

function blockMe(message) {
    console.log(message);
}

const filePath = './src/assets/info.txt'
const fileOptions = {
    encoding: 'utf-8'
}

blockMe('start reading')
//async/non blocking  file api :
const fileContent = fs.readFileSync(filePath, fileOptions)
console.log(fileContent)
blockMe('start ending')

........................................................................................
Think : what is default size of the worker pool thread? - 4

if you want to increase no of worker pool threads, that can increased via env variable

export UV_THREADPOOL_SIZE=15

Performance Tips:
   "Dont over use Workerpoll threads"
      -which eats memory
      -cpu need to do ctx switch-cpu overhead.
.............................................................................................
 
   From the event loop, dont call blocking apis : Dont block Event loop thread 
                       Gloden Rule : Dont block event loop thread
.......................................................................................

Event Loop thread can be blocked

-blocking io apis
-CPU intensive apis
   -crypto module  when it computes long hash values, which takes lot of cpu time
   -zip compression algorthim may block



eg:
const fs = require('fs')


function blockMe(message){
  console.log(message);
}

const filePath = './src/assets/info.txt'
const fileOptions = {
    encoding:'utf-8'
}

blockMe('start reading')
function sleep(ms){
    const time =  Date.now() + ms;
    while(Date.now() < time);
}
//async/non blocking  file api :
fs.readFile(filePath, fileOptions, (err, data) => {
    if (err) {
        throw err;
    }
    sleep(10000)
    console.log(data);
})

blockMe('start ending')
..............................................................................................
					File io 

1.blocking file io

2.non blocking file io
  -non streaming file io
       -the file content is loaded into node process memory first , then will be given to 
        caller
        -incase it is in network env,then more files are loaded into memory, then there will not be memory,so the process might crash.

  -streaming file io  
     sending data over io channel chunk by chunk
   
Types of Streams:

1.Readable Stream : input
2.Writeable stream : output
3.Duplex stream : read + write


Node has lot of built in stream apis
....................................

Built in readable Streams:

-HTTP responses, on the client
-HTTP requests, on the server
-fs read streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdout and stderr
-process.stdin

Writable Streams:

-HTTP requests, on the client
-HTTP responses, on the server
-fs write streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdin
-process.stdout, process.stderr


All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners

..........................................................................................					Streaming io is other wise called "evented io"
...........................................................................................

Common events in all io
.........................


1.data event:
 which is emitted by node, for each chunk.

2.close event:
  The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

3.end event:
 The 'end' event is emitted when there is no more data to be consumed from the stream.

3.Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.
.............................................................................................
				Performance tuning in io apis


Are you reading/writin files in network env?
Is it big size file?

Yes!

Dont use non streaming apis
 fs.readFile()

Use streaming apis?
 const fs = require('fs');
const path = require('path');
/**
 * What is __filename and __dirname?
 *   These are node global variables
 * 
 * Events: 
 *   listener : our program
 *    stream.on('nameoftheevent',callback)
 *   publisher : kernal fd table - will emit events when ever data /error/complete event is triggered.
 * 
 */

const fileName = path.join(__dirname, 'assets/big.file');
const config = {
    encoding: 'UTF-8'
}
const inputStream = fs.createReadStream(fileName, config);
//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk=> {
    console.log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    console.log('There will be no more data to read!');
    //console.log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    console.log(`Some thing went wrong! ${err}`)
});
..............................................................................................
					Networking IO
..............................................................................................

All netorking io operations are handled by "event loop thread".

Networking io apis/modules

1.http
2.tcp
3.udp

All networking modules are by default streamed io/evented io.

const http = require('http');

const server = http.createServer((req, res) => {
    //io operation : write hello into socket outputstream
    res.end('hello')
})

server.listen(3000, () => {
    console.log('Http server is up and running')
});

What if i want to build the enterprise applications?
  -Framework

Express.js
restify
loopback
hapi
..............................................................................................
					Express.js
..............................................................................................

Express.js abstraction on node core http module.

Express provides

-abstraction on http methods -  GET,POST,DELETE,PUT
-abstraction on http urls - /api /api/todos
-middlewares - extra logicas
-routers - which isloate domain models
.............................................................................................
				    Performance 
............................................................................................
What is perfomance measuring?
 Diagnose performance issues in application, in runtime components -v8,libuv,external systems
like databases,messaging middlewares.

What are symptoms to affect application peformance?

1.CPU usage
2.Blocking garbage collections
3.frequent event loop delay
4.blocking calls may block event loop thread or worker pool threads
5.IO issues - streaming , non streaming io issues



Use case : How to Block the event loop thread, how to identify the problem?

Code:
'use strict'

const express = require('express');
const app = express();

function sleep(ms) {
    const timer = Date.now() + ms
    while (Date.now() < timer);
}

app.get('/', (req, res, next) => {
    //block the event loop thread.
    sleep(30)
    res.send({})
    next()
})

app.listen(3000)
.............................................................................................
		Clinic.js - Simple But high expressive tool  Diagnose 
.............................................................................................

Setup :
 Install clinic tool.

Requirement
Node version > 8.11.

1.npm i clinic -g 


2.npm i autocannon -g

Clinic sub commands

1.doctor
2.flame
3.bubbleprof


Blocking Event loop:

'use strict'

const express = require('express');
const app = express();

function sleep(ms) {
    const timer = Date.now() + ms
    while (Date.now() < timer);
}

app.get('/', (req, res, next) => {
    //block the event loop thread.
    sleep(30)
    res.send({})
    next()
})

app.listen(3000)
.............................................................................................

How to test blocking event loop?

tunningapp>clinic doctor --autocannon [/] -- node src/sloweventloop


You can see the report
 -Recommendations - follow the recommendation for next activity.


FlameGraph:

Each block represents the time spent executing calls to a function.

"The wider the block, the more time was spent"

Blocks sit on the function that called them, so the stack below each block shows its stack trace.

Double clicking on a block will expand it and its children.

...........................
A hot function
This is a "hot" function - a lot of time was spent at the top of the stack, running the code inside this function. The brighter the colour on the exposed top of a block, the "hotter" it is compared to the rest of the profile.

This might signify a problem: for example, it might be a slow function that can be optimised, or that is called very many times by functions below it

............................................................................................
				slow io calls
............................................................................................

Detected a potential I/O issue

There may be long-running asynchronous activities
This can mean that the bottleneck is not the Node process at all, but rather an I/O operation
Diagnose: Use clinic bubbleprof to explore asynchronous delays â€“ run clinic bubbleprof -h to get started.
..............................................................................................

const express = require('express');
const fs = require('fs')
const path = require('path')
const tmp = path.join(__dirname, 'tmp')

const app = express();

app.get('/', function (req, res, next) {
    sleep(10) // mimic sync I/O by sleeping 10ms sync
    res.send({})
    next()
})
server.listen(3000)

process.on('SIGINT', function () {
    console.error('Caught SIGINT, shutting down.')
    try { fs.unlinkSync(tmp) } catch (e) { }
    server.close()
})

function sleep(ms) {
    var now = Date.now()
    while (Date.now() < now + ms) {
        fs.closeSync(fs.openSync(tmp, 'a'))
    }
}

>clinic doctor --autocannon [/] -- node src/sync-io

you will get 

Doctor has found a potential Event Loop issue:
There may be one or more long running synchronous operations blocking the thread
Mitigate: Implement HTTP 503 event-loop protection

Diagnose: Use clinic flame to discover CPU intensive function calls â€“ run clinic flame -h


Flame Graph:

How it is working?
 
 -doing some cpu sampling

What is CPU Sampling?

CPU sampling takes a snapshot of what is running at a set interval without noticeably slowing down your program. The aggregation of these snapshots gives us an estimate of how long the functions in your program are taking to execute.
..............................................................................................
"How long /How much time  the function is running on cpu?"

Process Architecture:

Every Process is  program.

Program is two types

1.passive program
   program which is not in main memory
2.active program
   program which is in main memory

All active programs are called as "process".

Any thing in main memory has structure - Process structure.

RSS:
Resident set size (RSS) is the amount of physical memory currently allocated for  process.

Stack:
 What is use of stack?

Program :
 variables 
 functions

variables + functions => class==> objects(dynamic memory)==>heap

function add(a,b){
  
   return a + b;

}

//function call
add(10,10)			


FlameGraph is generated based on the below question


When generating a flamegraph we are asking three key questions:

During the sampling period, which functions called each other?
How much time was each function observed on-CPU?
How much time was each function observed at the top of the stack?


Code Block : which takes most of the cpu time: hottest function

function initPayload(idSize = 20) {
  return function payload() {
    let chars = ''
    let n = idSize
    const date = Date.now()
    const radix = 36
    n *= n * idSize
    while (n--) {
      const num = date + n
      chars += num.toString(radix).toUpperCase()
    }
    const id = chars.slice(-idSize)
    return { date, id }
  }
}

function initPayload(idSize = 20) {
  if (idSize < 6) throw Error('idSize must be greater than 5')
  const max = 2147483647
  var count = 0
  return function payload() {
    count = (count + 1) % max
    const date = Date.now()
    const chars = count.toString(36).toUpperCase()
    const id = '0'.repeat(idSize - chars.length) + chars
    return { date, id }
  }
}
..............................................................................................
				  Flame Graph Testing
..............................................................................................

'use strict'

const express = require('express')

const app = express()
const payload = initPayload()

app.get('/', (req, res) => {
  res.send(payload())
})

app.listen(3000)

function initPayload (idSize = 20) {
  if (idSize < 6) throw Error('idSize must be greater than 5')
  return function payload () {
    let chars = ''
    let n = idSize
    const date = Date.now()
    const radix = 36
    n *= n * idSize
    while (n--) {
      const num = date + n
      chars += num.toString(radix).toUpperCase()
    }
    const id = chars.slice(-idSize)
    return { date, id }
  }
}

Get Report :  identify slow function calls;
..............................................
clinic flame --on-port 'autocannon  localhost:$PORT' -- node 1-server-with-slow-function.js

The clinic flame portion invokes the flame command tool.

The --on-port flag will execute the supplied script as soon as the server starts listening on a port.
The $PORT variable in that script is set to the first port that the server began listening on.

Everything after the double-dash (--) is the command which starts the server that we want to profile, in this case node 1-server-with-slow-function.js.

After running , we will get the report, dignosis it , and optimize the hottest function
.............................................................................................

Optimized Code:

'use strict'

const express = require('express')

const app = express()
const payload = initPayload()

app.get('/', (req, res) => {
  res.send(payload())
})

app.listen(3000)

function initPayload (idSize = 20) {
  if (idSize < 6) throw Error('idSize must be greater than 5')
  const max = 2147483647
  var count = 0
  return function payload () {
    count = (count + 1) % max
    const date = Date.now()
    const chars = count.toString(36).toUpperCase()
    const id = '0'.repeat(idSize - chars.length) + chars
    return {date, id}
  }
}

clinic flame --on-port 'autocannon localhost:$PORT' -- node 2-server-with-optimized-function.js

Now we got optimized result. - we have optimized initpayload function.

But it may still need optimization.
  go on optimize it
.............................................................................................
				   Doctor tool
 
blocking event loop
  -blocking calls -  cpu insentive task,blocking io apis
  -slow io calls
					Memory : Heap

How to identify memory leaks? Which code leaks memory? How to dignosis memory leaks
  
https://v8.dev/blog/trash-talk
https://nodesource.com/blog/memory-leaks-demystified
..............................................................................................

Steps:

1.code
const http = require('http')

const leak = []

function requestListener(req, res) {

  if (req.url === '/now') {
    let resp = JSON.stringify({ now: new Date() })
    leak.push(JSON.parse(resp))
    res.writeHead(200, { 'Content-Type': 'application/json' })
    res.write(resp)
    res.end()
  } else if (req.url === '/getSushi') {
    function importantMath() {
      let endTime = Date.now() + (5 * 1000);
      while (Date.now() < endTime) {
        Math.random();
      }
    }

    function theSushiTable() {
      return new Promise(resolve => {
        resolve('ğŸ£');
      });
    }

    async function getSushi() {
      let sushi = await theSushiTable();
      res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' })
      res.write(`Enjoy! ${sushi}`);
      res.end()
    }

    getSushi()
    importantMath()
  } else {
    res.end('Invalid request')
  }
}

const server = http.createServer(requestListener)
server.listen(process.env.PORT || 3000)

2. start the server --inspect 
node  --inspect mymem.js

3.open chrome dev tool ---> chrome://inspect

https://nodesource.com/blog/memory-leaks-demystified
..............................................................................................			 Best Production Practices to improve performance of node applications
.............................................................................................
Production best practices: performance and reliability:


Env where you can concentrate to improve performance

1.Dev Env:

1.Use gzip compression
   When you send response - big responses,images.... you need to compress that

var compression = require('compression')
var express = require('express')
var app = express()
app.use(compression())

Donâ€™t use synchronous functions
 blocking apis avoid as much as possible

Do logging correctly
  loggers are used to trace potential errors,root cause your application problems
morgan,Node.js

Handle exceptions properly
  try...catch, promises
  express global error middlewares

Use clinic.js to identify event loop ,io,memory leaks... fix it.

.............................................................................................
				Production Env best pratices
.............................................................................................

Set NODE_ENV to â€œproductionâ€
Ensure your app automatically restarts
Run your app in a cluster
Cache request results
Use a load balancer
Use a reverse proxy
	

Set NODE_ENV to â€œproductionâ€: Environment variables:
....................................................
Env variables are variables to scale your application in many context.

for dynamic settings like database , usernames,passwords, urls, gloable variables has to be externalized.

Node REPL

process

process.env:
 it is variable holding global variables and its values inside an object

process.env = {
 variable:value
}

............................................................................................
How to pass env variables to program?


via command line

in windows

>SET PORT=8080
>node myapp.js

console.log(process.env.PORT)

via .env file

create .env file

PORT=9090
HOST=example.com

how to env file?
dotenv

npm install dotenv

myapp.js

require('dotenv').config()

console.log(process.env.PORT)
console.log(process.env.HOST)
			
>node myapp.js
9090
example.com
............................................................................................
				Set NODE_ENV to â€œproductionâ€

Every express application uses "production" value , to optimize the application.

Cache view templates.
Cache CSS files generated from CSS extensions.
Generate less verbose error messages.

Please refer os settings 
http://upstart.ubuntu.com/cookbook/#environment-variables

.............................................................................................
				Process Manager
............................................................................................

Monitoring the Running applications:

-CPU monitoring
-Memory monitoring
-network tracffic monitoring

StrongLoop Process Manager
PM2
Forever

Scalling the Applications
 increasing or decreasing no of copies of the applications.

Clusters

load balancers
...........................................&&&&............................................
					PM2 -Process Manager 2

-Scalling : Running mulitple copies of the same application  -clusters.


start application in cluster mode

pm2 start app.js -i max
[PM2] Starting c:\session\vodafone\myapp\app.js in cluster_mode (0 instance)
[PM2] Done.
â‡† PM2+ activated | Instance Name: LAPTOP-R2TGGFDL-e440 | Dash: https://app.pm2.io/#/r/bizimruz6md00eo
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ id â”‚ name               â”‚ mode     â”‚ â†º    â”‚ status    â”‚ cpu      â”‚ memory   â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1  â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 38.7mb   â”‚
â”‚ 2  â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 38.8mb   â”‚
â”‚ 3  â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 39.1mb   â”‚
â”‚ 4  â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 39.0mb   â”‚
â”‚ 5  â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 38.9mb   â”‚
â”‚ 6  â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 38.8mb   â”‚
â”‚ 7  â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 39.4mb   â”‚
â”‚ 8  â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 39.3mb   â”‚
â”‚ 9  â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 38.8mb   â”‚
â”‚ 10 â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 38.7mb   â”‚
â”‚ 11 â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 38.7mb   â”‚
â”‚ 12 â”‚ app                â”‚ cluster  â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 38.3mb   â”‚
â”‚ 0  â”‚ index              â”‚ fork     â”‚ 0    â”‚ online    â”‚ 0%       â”‚ 39.0mb   â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Demonized : background process.

Watching logs for started servers

.............................................................................................
					Commond line options


Max Memory Setting:
--max-old-space-size=SIZE (in megabytes)#
Sets the max memory size of V8's old memory section. As memory consumption approaches the limit, V8 will spend more time on garbage collection in an effort to free unused memory.

On a machine with 2 GB of memory, consider setting this to 1536 (1.5 GB) to leave some memory for other uses and avoid swapping.



$ node --max-old-space-size=1536 index.js
